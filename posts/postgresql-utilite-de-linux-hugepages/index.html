<!doctype html><html lang=fr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>PostgreSQL : Pourquoi Linux HugePages est super important pour les serveurs de base de données? | Les amis de Percona</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Apprendre comment Linux Huge Pages et ses améliorations peuvent potentiellement sauver le serveur de base de données des OOM Killers et des plantages associés"><meta name=generator content="Hugo 0.80.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><meta property="og:title" content="PostgreSQL : Pourquoi Linux HugePages est super important pour les serveurs de base de données?"><meta property="og:description" content="Apprendre comment Linux Huge Pages et ses améliorations peuvent potentiellement sauver le serveur de base de données des OOM Killers et des plantages associés"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lesamisdepercona.fr/posts/postgresql-utilite-de-linux-hugepages/"><meta property="og:image" content="https://www.lesamisdepercona.fr/thumbnail2022/article04.jpg"><meta property="article:published_time" content="2022-02-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-04T00:00:00+00:00"><meta itemprop=name content="PostgreSQL : Pourquoi Linux HugePages est super important pour les serveurs de base de données?"><meta itemprop=description content="Apprendre comment Linux Huge Pages et ses améliorations peuvent potentiellement sauver le serveur de base de données des OOM Killers et des plantages associés"><meta itemprop=datePublished content="2022-02-04T00:00:00+00:00"><meta itemprop=dateModified content="2022-02-04T00:00:00+00:00"><meta itemprop=wordCount content="2084"><meta itemprop=image content="https://www.lesamisdepercona.fr/thumbnail2022/article04.jpg"><meta itemprop=keywords content="PostgreSQL,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.lesamisdepercona.fr/thumbnail2022/article04.jpg"><meta name=twitter:title content="PostgreSQL : Pourquoi Linux HugePages est super important pour les serveurs de base de données?"><meta name=twitter:description content="Apprendre comment Linux Huge Pages et ses améliorations peuvent potentiellement sauver le serveur de base de données des OOM Killers et des plantages associés"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W9SYN1YL24"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-W9SYN1YL24');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-203534013-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-203534013-1');</script></head><body class="ma0 avenir bg-near-white"><header><div class=bg-dark-blue><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/img/logo.png class="w100 mw5-ns" alt="Les amis de Percona"></a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="Articles page">Articles</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="Qui Sommes Nous? page">Qui Sommes Nous?</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/tags/ title="Tags page">Tags</a></li></ul></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://www.lesamisdepercona.fr/posts/postgresql-utilite-de-linux-hugepages/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://www.lesamisdepercona.fr/posts/postgresql-utilite-de-linux-hugepages/&text=PostgreSQL%20:%20Pourquoi%20Linux%20HugePages%20est%20super%20important%20pour%20les%20serveurs%20de%20base%20de%20donn%c3%a9es?" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.lesamisdepercona.fr/posts/postgresql-utilite-de-linux-hugepages/&title=PostgreSQL%20:%20Pourquoi%20Linux%20HugePages%20est%20super%20important%20pour%20les%20serveurs%20de%20base%20de%20donn%c3%a9es?" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30C64 50.568 50.568 64 34 64zM26.354 48.137V27.71h-6.789v20.427H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">PostgreSQL : Pourquoi Linux HugePages est super important pour les serveurs de base de données?</h1><p class=tracked>By <strong>Francis</strong></p><time class="f6 mv4 dib tracked" datetime=2022-02-04T00:00:00Z>February 4, 2022</time>
<span class="f6 mv4 dib tracked">- 10 minutes read</span>
<span class="f6 mv4 dib tracked">- 2084 words</span></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-100-l"><p><img src=/thumbnail2022/article04.jpg alt=thumbnail></p><p>Souvent, les utilisateurs viennent nous voir avec des incidents de plantage de base de données dus à OOM Killer. Le Out Of Memory Killer met fin aux processus PostgreSQL et reste la principale raison de la plupart des plantages de la base de données PostgreSQL qui nous sont signalés. Il peut y avoir plusieurs raisons pour lesquelles une machine hôte peut manquer de mémoire, et les problèmes les plus courants sont :</p><ol><li>Mémoire mal réglée sur la machine hôte.</li><li>Une valeur élevée de work_mem est spécifiée globalement (au niveau de l&rsquo;instance). Les utilisateurs sous-estiment souvent l&rsquo;effet multiplicateur de telles décisions globales.</li><li>Le nombre élevé de connexions. Les utilisateurs ignorent le fait que même une connexion non active peut contenir une bonne quantité d&rsquo;allocation de mémoire.</li><li>D&rsquo;autres programmes co-hébergés sur la même machine consomment des ressources.</li></ol><p>Même si nous avions l&rsquo;habitude d&rsquo;aider à régler à la fois les machines hôtes et les bases de données, nous ne prenons pas toujours le temps d&rsquo;expliquer comment et pourquoi les HugePages sont importantes et de le justifier avec des données. Grâce aux sondages répétés de mon ami et collègue <a href=https://www.percona.com/blog/author/fernando-laudares/>Fernando </a>, je n&rsquo;ai pas pu m&rsquo;empêcher de le faire cette fois.</p><h2 id=le-problème>Le problème</h2><p>Permettez-moi d&rsquo;expliquer le problème avec un cas testable et reproductible. Cela pourrait être utile si quelqu&rsquo;un veut tester le cas à sa manière.</p><h3 id=environnement-dessai>Environnement d&rsquo;essai</h3><p>La machine de test est équipée de 40 cœurs de processeur (80 vCPU ) et de 192 Go de mémoire installée. Je ne veux pas surcharger ce serveur avec trop de connexions, donc seulement 80 connexions sont utilisées pour le test. Oui, seulement 80 connexions, ce à quoi nous devrions nous attendre dans n&rsquo;importe quel environnement et c&rsquo;est très réaliste. Transparent HugePages (THP) est désactivé. Je ne veux pas détourner le sujet en expliquant pourquoi ce n&rsquo;est pas une bonne idée d&rsquo;avoir THP pour un serveur de base de données, mais je m&rsquo;engage à préparer un autre blog.</p><p>Afin d&rsquo;avoir une connexion relativement persistante, tout comme celles des poolers côté application (ou même des poolers de connexions externes), pgBouncer est utilisé pour rendre les 80 connexions persistantes tout au long des tests. La suite est la configuration pgBouncer utilisée :</p><pre><code>[databases]
sbtest2 = host=localhost port=5432 dbname=sbtest2

[pgbouncer]
listen_port = 6432
listen_addr = *
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
logfile = /tmp/pgbouncer.log
pidfile = /tmp/pgbouncer.pid
admin_users = postgres
default_pool_size=100
min_pool_size=80
server_lifetime=432000
</code></pre><p>Comme nous pouvons le voir, le paramètre server_lifetime est spécifié à une valeur élevée pour ne pas détruire la connexion du pooler à PostgreSQL. Après PostgreSQL , des modifications de paramètres sont incorporées pour imiter certains des paramètres d&rsquo;environnement client courants.</p><pre><code>logging_collector = 'on'
max_connections = '1000'
work_mem = '32MB'
checkpoint_timeout = '30min'
checkpoint_completion_target = '0.92'
shared_buffers = '138GB'
shared_preload_libraries = 'pg_stat_statements'
</code></pre><p>La charge de test est créée à l&rsquo;aide de sysbench</p><pre><code>sysbench /usr/share/sysbench/oltp_point_select.lua --db-driver=pgsql --pgsql-host=localhost --pgsql-port=6432 --pgsql-db=sbtest2 --pgsql-user=postgres --pgsql-password=vagrant --threads=80 --report-interval=1 --tables=100 --table-size=37000000 prepare
</code></pre><p>et puis</p><pre><code>sysbench /usr/share/sysbench/oltp_point_select.lua --db-driver=pgsql --pgsql-host=localhost --pgsql-port=6432 --pgsql-db=sbtest2 --pgsql-user=postgres --pgsql-password=vagrant --threads=80 --report-interval=1 --time=86400  --tables=80 --table-size=37000000  run
</code></pre><p>La première étape de préparation place une charge en écriture sur le serveur et la seconde une charge en lecture seule.</p><p>Je n&rsquo;essaie pas d&rsquo;expliquer la théorie et les concepts derrière HugePages , mais je me concentre sur l&rsquo;analyse d&rsquo;impact. Veuillez vous référer à l&rsquo;article LWN : <a href=https://lwn.net/Articles/717293/>Five-Level Page Tables </a>et l’article d&rsquo;Andres Freund <a href=https://blog.anarazel.de/2020/10/07/measuring-the-memory-overhead-of-a-postgres-connection/>Measuring the Memory Overhead of a Postgres Connection </a>pour comprendre certains concepts.</p><h2 id=test-dobservations>Test d’Observations</h2><p>Pendant le test, la consommation de mémoire a été vérifiée à l&rsquo;aide de la commande de l&rsquo;utilitaire free Linux. Lors de l&rsquo;utilisation du pool régulier de pages de mémoire, la consommation a commencé avec une valeur très faible. Mais il était en augmentation constante (voir la capture d&rsquo;écran ci-dessous). La mémoire « disponible » est épuisée plus rapidement.</p><p><img src=/posts/2022/article04/img01.png alt=image01></p><p>Vers la fin, il a également commencé l&rsquo;activité d&rsquo;échange. L&rsquo;activité d&rsquo;échange est capturée dans la sortie vmstat ci-dessous :</p><p><img src=/posts/2022/article04/img02.png alt=image02></p><p>Informations de <code>/proc/meminfo</code> révèlent que la taille totale de la table de pages est passée de <strong>25+Go à 45 Mo</strong> .</p><p><img src=/posts/2022/article04/img03.png alt=image03></p><p>Ce n&rsquo;est pas seulement un gaspillage de mémoire ; il s&rsquo;agit d&rsquo;une surcharge énorme qui a un impact sur l&rsquo;exécution globale du programme et du système d&rsquo;exploitation. Cette taille correspond au <strong>total des entrées inférieures de la PageTable</strong> des 80+ processus PostgreSQL .</p><p>La même chose peut être vérifiée en vérifiant chaque processus PostgreSQL . Voici un exemple:</p><p><img src=/posts/2022/article04/img04.png alt=image04></p><p>Ainsi, la taille totale de PageTable ( <strong>25 Go</strong> ) doit être d&rsquo;environ cette valeur * 80 (connexions). Étant donné que ce benchmark synthétique envoie une charge de travail presque similaire à travers toutes les connexions, tous les processus individuels ont des valeurs très proches de ce qui a été capturé ci-dessus.</p><p>La ligne Shell suivante peut être utilisée pour vérifier le Pss (Proportional set size). Étant donné que PostgreSQL utilise la mémoire partagée Linux, se concentrer sur Rss n&rsquo;a aucun sens.</p><pre><code>for PID in $(pgrep &quot;postgres|postmaster&quot;) ; do awk '/Pss/ {PSS+=$2} END{getline cmd &lt; &quot;/proc/'$PID'/cmdline&quot;; sub(&quot;\0&quot;, &quot; &quot;, cmd);printf &quot;%.0f --&gt; %s (%s)\n&quot;, PSS, cmd, '$PID'}' /proc/$PID/smaps ; done|sort -n
</code></pre><p>Sans informations Pss, il n&rsquo;y a pas de méthode simple pour comprendre la responsabilité de la mémoire par processus.</p><p>Dans un système de base de données typique où nous avons une charge DML considérable, les processus d&rsquo;arrière-plan de PostgreSQL tels que Checkpointer , Background Writer ou Autovaccum toucheront beaucoup de pages dans la mémoire partagée. Le Pss correspondant sera plus élevé pour ces processus.</p><p><img src=/posts/2022/article04/img05.png alt=image05></p><p><strong>Cela devrait expliquer pourquoi Checkpointer , Background worker ou même le Postmaster devient souvent la victime/cible habituelle d&rsquo;un OOM Killer. Comme nous pouvons le voir ci-dessus, ils portent la plus grande responsabilité de la mémoire partagée.</strong></p><p>Après plusieurs heures d&rsquo;exécution, la session individuelle touchait plus de pages de mémoire partagée. En conséquence, par processus, les valeurs Pss ont été réorganisées : Checkpointer est moins responsable car les autres sessions partagent la responsabilité.</p><p><img src=/posts/2022/article04/img06.png alt=image06></p><p>Cependant, le point de contrôle conserve la part la plus élevée.</p><p>Même si ce n&rsquo;est pas important pour ce test, il convient de mentionner que ce type de modèle de charge est spécifique au benchmarking synthétique car chaque session fait à peu près le même travail. Ce n&rsquo;est pas une bonne approximation de la charge d&rsquo;application typique, où nous voyons généralement les pointeurs de contrôle et les rédacteurs d&rsquo;arrière-plan porter la responsabilité principale.</p><h2 id=la-solution--activer-les-hugepages>La solution : Activer les HugePages</h2><p>La solution à ces tables de pages gonflées et aux problèmes associés consiste à utiliser HugePages à la place. Nous pouvons déterminer la quantité de mémoire à allouer à HugePages en vérifiant le VmPeak du processus postmaster. Par exemple, si 4357 est le PID du postmaster :</p><pre><code>grep ^VmPeak /proc/4357/status
</code></pre><p>Cela donne la quantité de mémoire requise en Ko :</p><pre><code>VmPeak: 148392404 kB
</code></pre><p>Tout cela doit s&rsquo;intégrer dans d&rsquo;énormes pages. Conversion de cette valeur en pages de 2 Mo :</p><pre><code>postgres=# select 148392404/1024/2;
?column?
----------
    72457
(1 row)
</code></pre><p>Spécifiez cette valeur dans <code>/etc/sysctl.conf</code> pour <code>vm.nr\_hugepages</code> , par exemple :</p><pre><code>vm.nr_hugepages = 72457
</code></pre><p>Arrêtons maintenant l&rsquo;instance PostgreSQL et j’execute :</p><pre><code>sysctl -p
</code></pre><p>Je dois vérifier si le nombre de huge pages demandé est créé ou non :</p><pre><code>grep ^Huge /proc/meminfo
HugePages_Total:   72457
HugePages_Free:    72457
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
Hugetlb:        148391936 kB
</code></pre><p>Si nous démarrons PostgreSQL à ce stade, nous pourrions voir que HugePages_Rsvd est alloué.</p><pre><code>$ grep ^Huge /proc/meminfo
HugePages_Total:   72457
HugePages_Free:    70919
HugePages_Rsvd:    70833
HugePages_Surp:        0
Hugepagesize:       2048 kB
Hugetlb:        148391936 kB
</code></pre><p>Si tout va bien, je préférerais m&rsquo;assurer que PostgreSQL utilise toujours HugePages . car je préférerais un échec de démarrage de PostgreSQL plutôt que des problèmes/crashs plus tard.</p><pre><code>postgres=# ALTER SYSTEM SET huge_pages = on;
</code></pre><p>La modification ci-dessus nécessite un redémarrage de l' instance PostgreSQL .</p><h2 id=tests-avec-hugepages-on>Tests avec HugePages &ldquo;ON&rdquo;</h2><p>Les HugePages sont créées à l&rsquo;avance avant même le démarrage de PostgreSQL . PostgreSQL les alloue et les utilise. Il n&rsquo;y aura donc même pas de changement notable dans la sortie <code>free</code> avant et après le démarrage. PostgreSQL alloue sa mémoire partagée dans ces HugePages si elles sont déjà disponibles. PostgreSQL <code>shared\_buffers</code> est le plus gros occupant de cette mémoire partagée.</p><p><img src=/posts/2022/article04/img07.png alt=image07></p><p>La première sortie de <code>free - h</code> dans la capture d&rsquo;écran ci-dessus est générée avant le démarrage de PostgreSQL et la seconde après le démarrage de PostgreSQL . Comme nous pouvons le voir, il n&rsquo;y a pas de changement notable</p><p>J&rsquo;ai fait le même test qui a duré plusieurs heures et il n&rsquo;y a eu aucun changement; le seul changement notable, même après de nombreuses heures d&rsquo;exécution, est le déplacement de la mémoire &ldquo;libre&rdquo; vers le cache du système de fichiers , ce qui est attendu et ce que nous voulons réaliser. La mémoire totale &ldquo;disponible&rdquo; est restée à peu près constante, comme nous pouvons le voir dans la capture d&rsquo;écran suivante.</p><p><img src=/posts/2022/article04/img08.png alt=image08></p><p>La taille totale des tableaux de pages est restée à peu près la même :</p><p><img src=/posts/2022/article04/img09.png alt=image09></p><p>Comme nous pouvons le voir, la différence est énorme : seulement 61 Mo avec HugePages au lieu de 25 + Go auparavant. Le pss par session a également été considérablement réduit :</p><p><img src=/posts/2022/article04/img10.png alt=image10></p><p>Le plus gros avantage que j&rsquo;ai pu observer est que CheckPointer ou Background Writer n&rsquo;est plus responsable de plusieurs Go de RAM.</p><p><img src=/posts/2022/article04/img11.png alt=image11></p><p>Au lieu de cela, ils ne sont responsables que de quelques Mo de consommation. De toute évidence, ils ne seront plus une victime potentielle de l&rsquo;OOM Killer.</p><h2 id=conclusion>Conclusion</h2><p>Dans cet article de blog, nous avons expliqué comment Linux Huge Pages peut potentiellement sauver le serveur de base de données des OOM Killers et des plantages associés. Nous pouvait voir deux améliorations :</p><ol><li>La consommation globale de mémoire a été réduite par une grande marge. Sans HugePages, le serveur manquait presque de mémoire (mémoire disponible complètement épuisée et activité d&rsquo;échange démarrée). Cependant, une fois que nous sommes passés à HugePages, 38 à 39 Go sont restés en tant que cache du système de fichiers disponible/Linux . C&rsquo;est un énorme économie .</li><li>Lorsque HugePages est activé, les processus d&rsquo;arrière-plan PostgreSQL ne sont pas pris en compte pour une grande quantité de mémoire partagée. Ainsi, ils ne seront pas facilement des candidats victimes/cibles pour OOM Killer.</li></ol><p>Ces améliorations peuvent potentiellement sauver le système s&rsquo;il est au bord de la condition OOM, mais je ne veux pas prétendre que cela protégera la base de données de toutes les conditions OOM pour toujours.</p><p>HugePage (hugetlbfs ) a atterri à l&rsquo;origine dans le noyau Linux en 2002 pour répondre aux exigences des systèmes de bases de données qui doivent traiter une grande quantité de mémoire. J&rsquo;ai pu voir que les objectifs de conception sont toujours valables.</p><p>HugePages présente d&rsquo;autres avantages indirects supplémentaires :</p><ol><li>Les HugePages ne sont jamais échangées. Lorsque les tampons partagés PostgreSQL sont dans HugePages , cela peut produire des performances plus cohérentes et prévisibles. je vais discuter cela dans un autre article.</li><li>Linux utilise une méthode <a href=https://lwn.net/Articles/717293/>de recherche de page à plusieurs niveaux </a>. Les HugePages sont implémentées à l&rsquo;aide de pointeurs directs vers les pages de la couche intermédiaire (une énorme page de 2 Mo se trouverait directement au niveau PMD, sans page PTE intermédiaire). La traduction d&rsquo;adresse devient considérablement plus simple. Comme il s&rsquo;agit d&rsquo;une opération à haute fréquence dans un serveur de base de données avec une grande quantité de mémoire, les gains sont multipliés.</li></ol><p><strong>Remarque :</strong> les HugePages dont il est question dans cet article de blog concernent des pages énormes de taille fixe (2 Mo).</p><p>De plus, en passant, je tiens à mentionner qu&rsquo;il y a beaucoup d&rsquo;améliorations dans <strong>Transparent HugePages (THP)</strong> au fil des ans, ce qui permet aux applications d&rsquo;utiliser HugePages sans aucune modification de code. THP est souvent considéré comme un remplacement des HugePages classiques (hugetlbfs ) pour une charge de travail générique. Cependant, l&rsquo;utilisation de THP est déconseillée sur les systèmes de base de données car elle peut entraîner une fragmentation de la mémoire et des retards accrus. Je veux couvrir ce sujet dans un autre article et je veux juste mentionner qu&rsquo;il ne s&rsquo;agit pas d&rsquo;un problème spécifique à PostgreSQL , mais qu&rsquo;il affecte tous les systèmes de base de données. Par exemple,</p><ol><li>Oracle recommande de désactiver TPH. <a href=https://docs.oracle.com/en/database/oracle/oracle-database/19/ladbi/disabling-transparent-hugepages.html#GUID-02E9147D-D565-4AF8-B12A-8E6E9F74BEEA>Lien de référence</a></li><li>MongoDB recommande de désactiver THP. <a href=https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/>Lien de référence</a></li><li>&ldquo;THP est connu pour entraîner une dégradation des performances avec PostgreSQL pour certains utilisateurs sur certaines versions de Linux.&rdquo; <a href=https://www.postgresql.org/docs/current/runtime-config-resource.html>Lien de référence</a></li></ol><p>Alors que de plus en plus d&rsquo;entreprises envisagent de migrer d&rsquo;Oracle ou d&rsquo;implémenter de nouvelles bases de données parallèlement à leurs applications, PostgreSQL est souvent la meilleure option pour ceux qui souhaitent s&rsquo;exécuter sur des bases de données open source.</p><p>Source : <a href=https://www.percona.com/blog/why-linux-hugepages-are-super-important-for-database-servers-a-case-with-postgresql/>Percona</a></p><p>A lire : <a href=https://learn.percona.com/why-customers-choose-percona-postgres>Pourquoi les utilisateurs utilisent Percona for PostgreSQL</a></p><ul class=pa0><li class=list><a href=/tags/postgresql class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">PostgreSQL</a></li></ul><div class="mt6 instapaper_ignoref"></div></div></article></main><footer class="bg-dark-blue bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://www.lesamisdepercona.fr/>&copy; Les amis de Percona 2022</a><div></div></div></footer></body></html>