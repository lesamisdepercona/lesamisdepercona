<!doctype html><html lang=fr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Impact du réseau et du curseur sur les performances des requêtes de PostgreSQL | Les amis de Percona</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Traduit à partir de l'article de Jobin Augustine intitulé, Impact of Network and Cursor on Query Performance of PostgreSQL"><meta name=generator content="Hugo 0.80.0"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><link rel="shortcut icon" href=/img/favicon.png type=image/x-icon><meta property="og:title" content="Impact du réseau et du curseur sur les performances des requêtes de PostgreSQL"><meta property="og:description" content="Traduit à partir de l'article de Jobin Augustine intitulé, Impact of Network and Cursor on Query Performance of PostgreSQL"><meta property="og:type" content="article"><meta property="og:url" content="https://www.lesamisdepercona.fr/posts/impact-du-reseau-et-du-curseur-sur-les-performances-des-requetes-de-postgresql/"><meta property="og:image" content="https://www.lesamisdepercona.fr/thumbnail/article20-PostgreSQL.jpg"><meta property="article:published_time" content="2021-10-17T11:43:01+04:00"><meta property="article:modified_time" content="2021-10-17T11:43:01+04:00"><meta itemprop=name content="Impact du réseau et du curseur sur les performances des requêtes de PostgreSQL"><meta itemprop=description content="Traduit à partir de l'article de Jobin Augustine intitulé, Impact of Network and Cursor on Query Performance of PostgreSQL"><meta itemprop=datePublished content="2021-10-17T11:43:01+04:00"><meta itemprop=dateModified content="2021-10-17T11:43:01+04:00"><meta itemprop=wordCount content="2193"><meta itemprop=image content="https://www.lesamisdepercona.fr/thumbnail/article20-PostgreSQL.jpg"><meta itemprop=keywords content="PostgreSQL,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.lesamisdepercona.fr/thumbnail/article20-PostgreSQL.jpg"><meta name=twitter:title content="Impact du réseau et du curseur sur les performances des requêtes de PostgreSQL"><meta name=twitter:description content="Traduit à partir de l'article de Jobin Augustine intitulé, Impact of Network and Cursor on Query Performance of PostgreSQL"><script async src="https://www.googletagmanager.com/gtag/js?id=G-W9SYN1YL24"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-W9SYN1YL24');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-203534013-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-203534013-1');</script></head><body class="ma0 avenir bg-near-white"><header><div class=bg-dark-blue><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/img/logo.png class="w100 mw5-ns" alt="Les amis de Percona"></a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="Articles page">Articles</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="Qui Sommes Nous? page">Qui Sommes Nous?</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/tags/ title="Tags page">Tags</a></li></ul></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://www.lesamisdepercona.fr/posts/impact-du-reseau-et-du-curseur-sur-les-performances-des-requetes-de-postgresql/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://www.lesamisdepercona.fr/posts/impact-du-reseau-et-du-curseur-sur-les-performances-des-requetes-de-postgresql/&text=Impact%20du%20r%c3%a9seau%20et%20du%20curseur%20sur%20les%20performances%20des%20requ%c3%aates%20de%20PostgreSQL" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.lesamisdepercona.fr/posts/impact-du-reseau-et-du-curseur-sur-les-performances-des-requetes-de-postgresql/&title=Impact%20du%20r%c3%a9seau%20et%20du%20curseur%20sur%20les%20performances%20des%20requ%c3%aates%20de%20PostgreSQL" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30C64 50.568 50.568 64 34 64zM26.354 48.137V27.71h-6.789v20.427H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">Impact du réseau et du curseur sur les performances des requêtes de PostgreSQL</h1><p class=tracked>By <strong>Francis</strong></p><time class="f6 mv4 dib tracked" datetime=2021-10-17T11:43:01+04:00>October 17, 2021</time>
<span class="f6 mv4 dib tracked">- 11 minutes read</span>
<span class="f6 mv4 dib tracked">- 2193 words</span></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-100-l"><p>Plusieurs fois, nous voyons les utilisateurs de PostgreSQL se perdre sur la durée des requêtes/instructions signalée dans les journaux PostgreSQL. D&rsquo;autres outils PostgreSQL comme pgBadger présentent les mêmes données basées sur le fichier journal, ce qui augmente encore la confusion. Connaître l&rsquo;impact total de la surcharge et des curseurs liés au réseau est important non seulement pour atténuer la confusion, mais également pour obtenir les meilleures performances.</p><p>On peut se demander «Pourquoi discuter spécifiquement de la surcharge du réseau et des curseurs?». Eh bien, ce sont les coûts cachés après l&rsquo;exécution de la requête. Une fois que l&rsquo;exécution de la requête commence et qu&rsquo;il y a des données à fournir au client, ce sont les facteurs qui affectent principalement les performances. Donc, le point important que nous pouvons vouloir garder à l&rsquo;esprit est que puisque tout cela se produit en dehors de l&rsquo;exécution de la requête, <em><strong>les informations correspondantes ne seront pas disponibles via EXPLAIN (ANALYZE).</strong></em></p><h2 id=impact-du-réseau>Impact du réseau</h2><p>Pour la démonstration, j&rsquo;utilise une requête basée sur les tables pgBench.</p><pre><code>select a.bid, b.cnt from pgbench_accounts a,
   (select bid,count(*) cnt from pgbench_accounts group by bid) b
where b.bid &gt; a.bid;
</code></pre><p>Il n&rsquo;y a aucune signification pour cette requête. Une requête aléatoire est sélectionnée, ce qui prend un certain temps dans la base de données pour s&rsquo;exécuter.</p><p>Afin de capturer la sortie Explain Analyze, <a href=https://www.postgresql.org/docs/current/auto-explain.html>auto_explain</a> est utilisé. Les paramètres sont définis pour capturer toutes les déclarations qui prennent plus de 250 ms.</p><pre><code>ALTER SYSTEM SET auto_explain.log_min_duration = 250
</code></pre><p>Voici quelques autres paramètres pour capturer des détails supplémentaires avec EXPLAIN ANALYZE:</p><pre><code>ALTER SYSTEM SET auto_explain.log_analyze = on;
ALTER SYSTEM SET auto_explain.log_buffers=on;
ALTER SYSTEM SET auto_explain.log_timing=on;
ALTER SYSTEM SET auto_explain.log_verbose=on;
ALTER SYSTEM SET auto_explain.log_triggers=on;
ALTER SYSTEM SET auto_explain.log_wal=on;
</code></pre><p>Afin d&rsquo;illustrer la différence, la même requête sera exécutée à partir de :</p><p>\1. Le serveur hôte de la base de données</p><p>\2. Le serveur hôte de l&rsquo;application qui est connecté sur un réseau</p><h2 id=requêtes-renvoyant-un-grand-nombre-de-lignes>Requêtes renvoyant un grand nombre de lignes</h2><p><strong>Cas 1. Exécution sur l&rsquo;hôte de base de données lui-même</strong></p><p>Voici les quelques lignes des journaux PostgreSQL générés par auto_explain :</p><pre><code>2021-08-02 03:27:56.347 UTC [25537] LOG:  duration: 1591.784 ms  plan:
        Query Text: select a.bid, b.cnt from pgbench_accounts a,
           (select bid,count(*) cnt from pgbench_accounts group by bid) b
        where b.bid &gt; a.bid;
        Nested Loop  (cost=12322.13..63020.46 rows=833333 width=12) (actual time=119.739..1069.924 rows=1000000 loops=1)
          Output: a.bid, b.cnt
          Join Filter: (b.bid &gt; a.bid)
          Rows Removed by Join Filter: 1500000
          ...
</code></pre><p>Comme nous pouvons le voir, la boucle imbriquée externe de la requête a été achevée en <strong>1069,924 ms,</strong> renvoyant 1 million d&rsquo;enregistrements, mais la durée totale de la requête est de <strong>1591,784 ms.</strong> Quelle pourrait être la différence ?</p><p>Une analyse directe EXPLAIN ANALYZE montre que le <strong>temps de planification est inférieur à la milliseconde</strong> pour cette requête simple où les données proviennent d&rsquo;une seule table sans aucun index. Donc, le temps de planification ne devrait pas être la raison.</p><p><strong>Cas 2. Exécution à partir d&rsquo;un hôte d&rsquo;application distant</strong></p><p>Encore une fois, les informations du journal PostgreSQL sont différentes :</p><pre><code>2021-08-02 04:08:58.955 UTC [25617] LOG:  duration: 6568.659 ms  plan:
        Query Text: select a.bid, b.cnt from pgbench_accounts a,
           (select bid,count(*) cnt from pgbench_accounts group by bid) b
        where b.bid &gt; a.bid;
        Nested Loop  (cost=12322.13..63020.46 rows=833333 width=12) (actual time=140.644..1069.153 rows=1000000 loops=1)
          Output: a.bid, b.cnt
          Join Filter: (b.bid &gt; a.bid)
          Rows Removed by Join Filter: 1500000
          ...
</code></pre><p>Comme on peut le voir, la durée de l&rsquo;instruction a bondi à <strong>6568,659 ms !</strong> même si l&rsquo;exécution réelle de la requête est restée à peu près la même <strong>1069,153 ms</strong> . C&rsquo;est une énorme différence. Quelle pourrait être la raison?</p><h2 id=requêtes-renvoyant-un-nombre-de-lignes-inférieur>Requêtes renvoyant un nombre de lignes inférieur</h2><p>La requête mentionnée ci-dessus peut être légèrement modifiée pour ne renvoyer que les valeurs max. La requête de test modifiée peut ressembler à ceci :</p><pre><code>select max(a.bid), max(b.cnt) from pgbench_accounts a,
   (select bid,count(*) cnt from pgbench_accounts group by bid) b
where b.bid &gt; a.bid ;
</code></pre><p>Le plan ou l&rsquo;heure de la requête ne change pas grand-chose à part qu&rsquo;il y a un agrégat supplémentaire. Même s&rsquo;il y a un changement de plan qui n&rsquo;est pas pertinent pour le sujet, nous en discutons car nous ne considérons que la différence de temps entre le nœud externe de l&rsquo;exécution de la requête et la durée rapportée par PostgreSQL.</p><p><strong>Cas 1 : exécution sur l&rsquo;hôte de base de données lui-même</strong></p><pre><code>2021-08-03 06:58:14.364 UTC [28129] LOG:  duration: 1011.143 ms  plan:
        Query Text: select max(a.bid), max(b.cnt) from pgbench_accounts a,
           (select bid,count(*) cnt from pgbench_accounts group by bid) b
        where b.bid &gt; a.bid ;
        Aggregate  (cost=67187.12..67187.13 rows=1 width=12) (actual time=1010.914..1011.109 rows=1 loops=1)
          Output: max(a.bid), max(b.cnt)
          Buffers: shared hit=12622 read=3786
          -&gt;  Nested Loop  (cost=12322.13..63020.46 rows=833333 width=12) (actual time=135.635..908.315 rows=1000000 loops=1)
                Output: a.bid, b.cnt
                Join Filter: (b.bid &gt; a.bid)
                Rows Removed by Join Filter: 1500000
                Buffers: shared hit=12622 read=3786
</code></pre><p>Comme nous pouvons le voir, il n&rsquo;y a pas beaucoup de différence entre l&rsquo;achèvement de la requête 1011.109 et la durée rapportée 1011.143 ms. L&rsquo;observation jusqu&rsquo;à présent indique qu&rsquo;il y a du temps supplémentaire consommé lorsqu&rsquo;il y a beaucoup de lignes renvoyées.</p><p><strong>Cas 2 : Exécution de la déclaration à partir de l&rsquo;hôte distant</strong></p><pre><code>2021-08-03 06:55:37.221 UTC [28111] LOG:  duration: 1193.387 ms  plan:
        Query Text: select max(a.bid), max(b.cnt) from pgbench_accounts a,
           (select bid,count(*) cnt from pgbench_accounts group by bid) b
        where b.bid &gt; a.bid ;
        Aggregate  (cost=67187.12..67187.13 rows=1 width=12) (actual time=1193.139..1193.340 rows=1 loops=1)
          Output: max(a.bid), max(b.cnt)
          Buffers: shared hit=11598 read=4810
          -&gt;  Nested Loop  (cost=12322.13..63020.46 rows=833333 width=12) (actual time=124.508..1067.409 rows=1000000 loops=1)
                Output: a.bid, b.cnt
                Join Filter: (b.bid &gt; a.bid)
                Rows Removed by Join Filter: 1500000
                Buffers: shared hit=11598 read=4810
</code></pre><p>Encore une fois, il n&rsquo;y a pas beaucoup de différence 1193.340 vs 1193.387 ms. Dans l&rsquo;ensemble, je suis sûr de supposer à partir des résultats que si le transfert de données est minime, le serveur d&rsquo;applications sur une machine hôte différente ne fait pas beaucoup de différence ; en attendant, l&rsquo;impact est énorme s&rsquo;il y a beaucoup de transfert de résultats.</p><p><strong>Analyse des événements d&rsquo;attente</strong></p><p>Heureusement, les versions les plus récentes de PostgreSQL nous fournissent un excellent moyen de surveiller les informations <a href=https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW>« wait event » à partir de la vue pg_stat_activity</a> de la session/connexion.</p><p>Au support Percona, nous utilisons un <a href=https://raw.githubusercontent.com/percona/support-snippets/master/postgresql/pg_gather/gather.sql>script de pg_gather</a> snippet pour collecter des informations sur les performances, y compris les événements d&rsquo;attente, en collectant plusieurs échantillons. Le script collecte des échantillons d&rsquo;événements d&rsquo;attente toutes les 10 ms, il y aura donc 2 000 échantillons en 20 secondes. Outre l&rsquo;interface utilisateur, les informations recueillies peuvent également être analysées à l&rsquo;aide de requêtes backend.</p><p>Voici ce que j&rsquo;ai pu voir à propos du PID : 25617 (le cas du renvoi d&rsquo;un grand nombre de lignes à l&rsquo;hôte distant).</p><pre><code>postgres=# select pid,wait_event,count(*) from pg_pid_wait where pid=25617 group by 1,2 order by 3 desc;
  pid  |  wait_event  | count 
-------+--------------+-------
 25617 | ClientWrite  |   286
 25617 |              |    75
 25617 | DataFileRead |     3
(3 rows)
</code></pre><p>Les sessions passent plus de temps sur &ldquo;ClientWrite&rdquo; selon la <a href=https://www.postgresql.org/docs/current/monitoring-stats.html>documentation PostgreSQL</a> . </p><table><thead><tr><th>ClientEcrire</th><th>En attente d&rsquo;écriture des données sur le client.</th></tr></thead></table><p>C&rsquo;est le temps passé à écrire les données au client. Le wait_event NULL indique l&rsquo;utilisation du processeur.</p><h2 id=impact-des-curseurs>Impact des curseurs</h2><p>En règle générale, après l&rsquo;exécution d&rsquo;une requête, les données de résultat doivent être traitées par l&rsquo;application. Les curseurs sont utilisés pour conserver le résultat des requêtes et les traiter. L&rsquo;impact sur les performances des requêtes est principalement déterminé par l&rsquo;emplacement du curseur, que ce soit côté serveur PostgreSQL ou côté client. L&rsquo;emplacement du curseur devrait affecter le moment où la requête est émise à partir d&rsquo;un hôte d&rsquo;application distinct, je ne teste donc que ce cas.</p><p><strong>Curseurs côté client</strong></p><p>En général, c&rsquo;est le cas avec la plupart des clients et applications PostgreSQL. Les données sont récupérées intégralement vers le client de la base de données, puis traitées une par une.</p><p>Voici un simple extrait de code python (pour imiter la connexion de l&rsquo;application) pour le tester. (Seules les lignes pertinentes sont copiées.)</p><pre><code>   conn =  psycopg2.connect(connectionString)
   cur = conn.cursor()
   cur.itersize = 2000
   cur.execute(&quot;select a.bid, b.cnt from pgbench_accounts a, (select bid,count(*) cnt from pgbench_accounts group by bid) b where b.bid &gt; a.bid&quot;)
   row = cur.fetchone()
   while row is not None:
     print(row)
     time.sleep(0.001)
     row = cur.fetchone()

   conn.close()
</code></pre><p>Comme nous pouvons le voir, <code>itersize</code> est spécifié de sorte que seuls ces nombreux enregistrements doivent être récupérés à la fois pour le traitement et il y a un délai de 1 milliseconde dans une boucle utilisant <code>fetchone()</code> dans chaque boucle</p><p>Mais <em>aucun de ces éléments n&rsquo;affecte les performances des requêtes côté serveur,</em> car le curseur est déjà mis en cache côté client. L&rsquo;heure et la durée de la requête signalées sont similaires à l&rsquo;exécution à partir d&rsquo;un hôte d&rsquo;application distant pour un grand nombre de lignes. Comme attendu, l&rsquo;impact du réseau est clairement visible :</p><pre><code>2021-08-03 17:39:17.119 UTC [29180] LOG:  duration: 5447.793 ms  plan:
        Query Text: select a.bid, b.cnt from pgbench_accounts a, (select bid,count(*) cnt from pgbench_accounts group by bid) b where b.bid &gt; a.bid
        Nested Loop  (cost=12322.13..63020.46 rows=833333 width=12) (actual time=130.919..1240.727 rows=1000000 loops=1)
          Output: a.bid, b.cnt
          Join Filter: (b.bid &gt; a.bid)
          Rows Removed by Join Filter: 1500000
          Buffers: shared hit=1647 read=14761
          -&gt;  Seq Scan on public.pgbench_accounts a  (cost=0.00..13197.00 rows=500000 width=4) (actual time=0.086..183.503 rows=500000 loops=1)
                Output: a.aid, a.bid, a.abalance, a.filler
                Buffers: shared hit=864 read=7333
</code></pre><h2 id=curseurs-côté-serveur>Curseurs côté serveur</h2><p>La façon dont le curseur est créé et utilisé changera totalement si nous avons un curseur nommé qui reste côté serveur et que l&rsquo;instruction <code>cur = conn.cursor()</code> est modifiée pour inclure un nom comme <code>cur = conn.cursor('nom')</code></p><p>Comme le dit la documentation <a href=https://www.psycopg.org/docs/usage.html#server-side-cursors>psycopg2: (Le connecteur Python pour PostgreSQL)</a> : </p><p><em>« Psycopg encapsule le curseur côté serveur de la base de données dans des curseurs nommés. Un curseur nommé est créé à l&rsquo;aide de la méthode <a href=https://www.psycopg.org/docs/connection.html#connection.cursor>cursor()</a> en spécifiant le paramètre name"</em></p><p>Étonnamment, le journal PostgreSQL ne donne pas plus d&rsquo;informations sur la requête même si auto_explain est configuré. Aucune information sur la durée non plus. Il n&rsquo;y a qu&rsquo;une seule ligne d&rsquo;infos :</p><pre><code>2021-08-03 18:02:45.184 UTC [29249] LOG:  duration: 224.501 ms  statement: FETCH FORWARD 1 FROM &quot;curname&quot;
</code></pre><p>Le curseur PostgreSQL prend en charge diverses options FETCH avec des spécifications de taille personnalisées. Veuillez vous référer à <a href=https://www.postgresql.org/docs/current/plpgsql-cursors.html#id-1.8.8.9.6.5>la documentation de FETCH</a> pour plus de détails. Il appartient au pilote/connecteur de langage d&rsquo;encapsuler cette fonctionnalité dans les fonctions correspondantes.</p><p>Le pilote python pour PostgreSQL - psychopg2 - encapsule la fonctionnalité pour exécuter les lignes FETCH avec la taille de lot personnalisée spécifiée comme suit :</p><pre><code>cur.fetchmany(size=20000)
</code></pre><p>Ce qui produit une entrée de journal PostgreSQL comme:</p><pre><code>2021-08-05 05:13:30.728 UTC [32374] LOG:  duration: 262.931 ms  statement: FETCH FORWARD 20000 FROM &quot;curname&quot;
</code></pre><p>Comme prévu, la taille du fetch est augmentée.</p><p>Mais le point important à noter ici est : même si l&rsquo;itération de l&rsquo;application sur un curseur côté serveur a pris énormément de temps (plusieurs minutes), il n&rsquo;y a presque aucune information sur la requête ou la session dans les journaux PostgreSQL.</p><p>Ahhh! Cela pourrait être la chose la plus étrange à laquelle quelqu&rsquo;un pourrait s&rsquo;attendre.</p><h2 id=analyse-des-événements-dattente>Analyse des événements d&rsquo;attente</h2><p>Encore une fois, l&rsquo;analyse des événements d&rsquo;attente est utile pour comprendre ce qui se passe. Sur les 2000 échantillons d&rsquo;événements d&rsquo;attente collectés par le script pg_gather, les événements d&rsquo;attente ressemblent à ceci:</p><pre><code>  pid  |  wait_event  | count 
-------+--------------+-------
 30115 | ClientRead   |  1754
 30115 |   (CPU)      |   245
 30115 | DataFileRead |     1
</code></pre><p>Le temps est en attente de l&rsquo;événement de poids « ClientRead ». Cela signifie que le côté serveur attend que le client envoie la prochaine requête. Ainsi, un réseau lent entre le serveur d&rsquo;applications et le serveur de base de données peut affecter négativement les curseurs côté serveur. Mais aucune information ne sera disponible dans les journaux PostgreSQL sur la déclaration. </p><h2 id=conclusion>Conclusion</h2><p>Dans cet article de blog, j&rsquo;ai essayé d&rsquo;évaluer l&rsquo;impact du transfert d&rsquo;une grande quantité de données d&rsquo;un hôte de base de données vers un hôte d&rsquo;application.</p><p>VEUILLEZ NOTER : Les chiffres discutés dans l&rsquo;article de blog en termes de nombre de lignes et de temps enregistré n&rsquo;ont aucune pertinence absolue et peuvent changer d&rsquo;un système à l&rsquo;autre avec de nombreux facteurs environnementaux.</p><p>La discussion porte davantage sur les domaines d&rsquo;impact et ce à quoi nous devons nous attendre et comment analyser en tant qu&rsquo;utilisateur final plutôt que sur des chiffres absolus.</p><ol><li>Essayez toujours de spécifier le nombre minimum de colonnes dans la requête. Évitez « SELECT * » ou les colonnes qui ne sont pas utilisées du côté de l&rsquo;application pour éviter un transfert de données inutile. </li><li>Évitez d&rsquo;extraire un grand nombre de lignes à la fois dans l&rsquo;application. Si nécessaire, utilisez une pagination appropriée avec LIMIT et OFFSET. </li><li>Évitez autant que possible les curseurs côté serveur. PostgreSQL ne signale que la durée de la première récupération et les performances réelles de la requête peuvent passer inaperçues. Des requêtes peu performantes pourraient se cacher derrière.</li><li>Les curseurs côté client et le temps de traitement des données n&rsquo;affecteront pas les performances des requêtes côté serveur PostgreSQL.</li><li>L&rsquo;analyse des événements d&rsquo;attente est très pratique pour comprendre où le serveur passe du temps.</li></ol><p><strong>Percona Distribution for PostgreSQL fournit les meilleurs et les plus critiques des composants d&rsquo;entreprise de la communauté open source, dans une seule distribution, conçue et testée pour fonctionner ensemble.</strong></p><p><a href=https://www.percona.com/software/postgresql-distribution><strong>Téléchargez Percona Distribution pour PostgreSQL, C&rsquo;est gratuit !</strong></a></p><p>Source : <a href=https://www.percona.com/blog/impact-of-network-and-cursor-on-query-performance-of-postgresql/>Blog Percona</a></p><ul class=pa0><li class=list><a href=/tags/postgresql class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">PostgreSQL</a></li></ul><div class="mt6 instapaper_ignoref"></div></div></article></main><footer class="bg-dark-blue bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://www.lesamisdepercona.fr/>&copy; Les amis de Percona 2021</a><div></div></div></footer></body></html>